Base 10:

Base 10 includes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
Here is 243 in base 10:
243 = (102 * 2) + (101 * 4) + (100 * 3) = 200 + 40 + 3.

Base 7:
243(in base 7) = (72 * 2) + (71 * 4) + (70 * 3) = 98 + 28 + 3 = 129(in decimal).
Base 7 includes 0, 1, 2, 3, 4, 5, 6.
9 isn't in base 7, so how do we represent it in base 7?
9(in decimal) = (71 * 1) + (70 * 2) = 7 + 2. Our answer is going to be 12(base7) = 9(base10).

Base 2:
Base2/Binary:
What about base 2? Base 2 includes 0 and 1. It works the same as the others. Here are some good values to know:
210 = 1024, 29 = 512, 28 = 256, 27 = 128, etc.

Hexadecimal/Base 16:

BiTS AND BYTES(https://www.tutorialspoint.com/cprogramming/c_data_types.htm):
- Bit is one binary digit. Can be 0 or 1.
- Nibble is 4 bits.
- Byte is 8 bits.
- Word is 2 bytes.
- Double Word (DWORD) is 4 bytes. Twice the size of a word.
- Quad Word (QWORD) is 8 bytes. Four times the size of a word.

- Char - 1 byte (8 bits).
- Signed Int:
    16 bit is -32,768 to 32,767.
    32 bit is -2,147,483,648 to 2,147,483,647.
    64-bit is -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.

- Unsigned Int - Minimum is zero, maximum is twice that of a signed int (of the same size).
- Bool - 1 byte.

BINARY OPERATIONS:

- NOT ("!"): NOT 1 = 0, NOT 0 = 1, !1100 = 0011;
- AND ("&"): 1 AND 1 = 1, 1 AND 0 = 0, 0 AND 0 = 0, 1100 AND 1010 = 1000;
- OR ("|"): 1 OR 1 = 1, 1 OR 0 = 1, 0 OR 0 = 0, 1100 | 1010 = 1110;
- XOR ("^"): 1 XOR 1 = 0, 1 XOR 0 = 1, 0 XOR 0 = 0, 1100 ^ 1010 = 0110;
- NAND: NOT AND;
- NOR: NOT OR;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
REGISTERS(https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture):
RAX - Known as the accumulator register. Often used to store the return value of a function.
RBX - Sometimes known as the base register, not to be confused with the base pointer. Sometimes used as a base pointer for memory access.
RDX - Sometimes known as the data register.
RCX - Sometimes known as the counter register. Used as a loop counter.
RSI - Known as the source index. Used as the source pointer in string operations.
RDI - Known as the destination index. Used as the destination pointer in string operations.
RSP - The stack pointer. Holds the address of the top of the stack.
RBP - The base pointer. Holds the address of the base (bottom) of the stack.

If the data is too large to fit in a register, a register will hold a pointer to the data so it can be accessed.
##############################################################
PUSH instruction could be used to save a register in a way that it can later be restored.
В языках подобных С++ имплементированы два метода: Call и Ret, Call создает инструкцию с адресом(в бинарной нотации) и кладет на верхний уровень стека, Ret не содержит адреса, этот метод просто забирает верхнюю инструкцию и возвращает нас по указанному адресу. 
Сам стек, после возвращения данных и выполнения функций уничтожается и данные из него недоступны.
##############################################################
RAX is 64 bits, the lower 32 bits can be referenced with EAX, and the lower 16 bits can be referenced with AX. AX is broken down into two 8 bit portions. 
The high/upper 8 bits of AX can be referenced with AH. The lower 8 bits can be referenced with AL.

RAX consists of all 8 bytes which would be bytes 0-7. 
EAX consists of bytes 4-7, AX consists of bytes 6-7, AH consists of only byte 6, and AL consists of only byte 7 (the final byte).

RAX = 0x0123456789ABCDEF
EAX = 0x89ABCDEF
AX = 0xCDEF
AH = 0xCD
AL = 0xEF
##############################################################
FLOAT-POINT DATA TYPE REGISTERS:
YMM0 to YMM15 (64-bit) and XMM0 to XMM15 (32-bit).
The XMM registers are the lower half of the YMM registers, similar to how EAX is the lower 32 bits of RAX. 
Something unique about these registers is that they can be treated as arrays. In other words, they can hold multiple values. 
For example, YMM# registers are 256-bit wide each and can hold 4 64-bit values or 8 32-bit values. 
Similarly, the XMM# registers are 128-bits wide and can hold 2 64-bit values or 4 32-bit values.

EXTRA REGISTERS:
There are registers r8 to r15 which are designed to be used by integer type values (not floats or doubles).
R8 - Full 64-bit (8 bytes) register.
R8D - Lower double word (4 bytes).
R8W - Lower word (2 bytes)
R8B - Lower byte.
##############################################################
In C/C++ you can use dereferencing to get the value inside of a memory address.
Dereferencing:
```
int main(){
    int num = 10;
    int* ptr = &num; //ptr is a pointer to num, which means ptr is holding the memory address of num.
    return (*ptr + 5); //Then return the sum of what's at the address inside ptr (num which is 10) and 5.
}
```
##############################################################
LEA and square brackets:
- Square Brackets - Square brackets dereference in assembly. 
  For example, [var] is the address pointed to by var. In other words, when using [var] we want to access the memory address that var is holding.

- LEA - Ignore everything about square brackets when working with LEA. LEA is short for Load Effective Address and it's used for calculating and loading addresses.
        It's important to note that when working with the LEA instruction, square brackets do not dereference.
        LEA is used to load and calculate addresses, NOT data.
##############################################################
EXAMPLE 1:
lea RAX, [var] => load address of var in RAX; RAX is now acting as a pointer since it holds the address to the variable.
mov [RAX], 12 //Then 12 is moved into the address pointed to by RAX. The address pointed to by RAX is the var variable. If that Assembly was executed, var would be 12. 
                This is all the same as doing mov var, 12.
EXAXPLE 2:
lea RAX, [RCX+8] ;This will add 8 to the address inside RCX, and set RAX to the resulting address.
mov RAX, [RCX+8] ;This will add 8 to the address already held by RCX, then dereference the new address and put whatever is at that address into RAX.
##############################################################
MOVZX (MOVE ZERO EXTENSION):
Move to the lower 32 bits of RAX via EAX will zero out/zero extend the upper 32 bits. 
A move to anything less will not zero extend. So moving something into AX will not zero out the rest of RAX. 
If you do want to zero extend no matter what, use movzx which performs zero extension no matter what.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JUMP:
For unsigned comparisons:
- JB/JNAE (CF = 1) ; Jump if below/not above or equal
- JAE/JNB (CF = 0) ; Jump if above or equal/not below
- JBE/JNA (CF = 1 or ZF = 1) ; Jump if below or equal/not above
- JA/JNBE (CF = 0 and ZF = 0); Jump if above/not below or equal

For signed comparisons:
- JL/JNGE (SF <> OF) ; Jump if less/not greater or equal
- JGE/JNL (SF = OF) ; Jump if greater or equal/not less
- JLE/JNG (ZF = 1 or SF <> OF); Jump if less or equal/not greater
- JG/JNLE (ZF = 0 and SF = OF); Jump if greater/not less or equal
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

STATUS FLAGS:
Flags are contained in a register called EFLAGS (x86) or RFLAGS (x64).
- Zero Flag (ZF) - Set if the result of an operation is zero. Not set if the result of an operation is not zero.
- Carry Flag (CF) - Set if the last unsigned arithmetic operation carried (addition) or borrowed (subtraction) a bit beyond the register. It's also set when an operation would be negative if it wasn't for the operation being unsigned.
- Overflow Flag (OF) - Set if a signed arithmetic operation is too big for the register to contain.
- Sign Flag (SF) - Set if the result of an operation is negative.
- Adjust/Auxiliary Flag (AF) - Same as the carry flag but for Binary Coded Decimal (BCD) operations.
- Parity Flag (PF) - Set to 1 if the number of bits set in the last 8 bits is even. (10110100, PF=1; 10110101, PF=0)
- Trap Flag (TF) - Allows for single-stepping of programs.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How does the x64 Windows calling convention work?
- The first four parameters are passed in registers, LEFT to RIGHT. Parameters that are not floating-point values, such as integers, pointers, and chars, will be passed via RCX, RDX, R8, and R9 (in that order). 
    Floating-point parameters will be passed via XMM0, XMM1, XMM2, and XMM3 (in that order).
- If there is a mix of floating-point and integer values, they will still be passed via the register that corresponds to their position. 
    For example, func(1, 3.14, 6, 6.28) will pass the first parameter through RCX, the second through XMM1, the third through R8, and the last through XMM3.
- If the parameter being passed is too big to fit in a register then it is passed by reference (a pointer to the data in memory). 
    Parameters can be passed via any sized corresponding register. For example, RCX, ECX, CX, CH, and CL can all be used for the first parameter. 
    Any other parameters are pushed onto the stack, RIGHT to LEFT.
- There is always going to be space allocated on the stack for 4 parameters, even if there aren't any parameters.
##############################################################
STACK ACCESS:
- 1-4 Parameters: arguments will be pushed via their respective registers, left to right. The compiler will likely use RSP+0x0 to RSP+0x18 for other purposes.
- More Than 4 Parameters: the first four arguments are passed via registers, left to right, and the rest are pushed onto the stack starting at offset RSP+0x20, right to left. 
    This makes RSP+0x20 the fifth argument and RSP+0x28.

EXAMPLE: function(1,2,3,4,5,6,7,8)
MOV RCX 0x1 ; Going left to right.
MOV RDX 0x2
MOV R8 0x3
MOV R9 0x4
PUSH 0x8 ; Now going right to left.
PUSH 0x7
PUSH 0x6
PUSH 0x5
CALL function

https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170&viewFallbackFrom=vs-2019
##############################################################
CDECL (C DECLARATION):
- The parameters are passed on the stack backward (right to left).
- The base pointer (RBP) is saved so it can be restored.
- The return value is passed via EAX.
- The caller cleans the stack. This is what makes cdecl cool. Because the caller cleans the stack, cdecl allows for a variable number of parameters.

https://docs.microsoft.com/en-us/cpp/build/prolog-and-epilog?view=msvc-170&viewFallbackFrom=vs-2019
https://www.gamedeveloper.com/programming/x64-abi-intro-to-the-windows-x64-calling-convention

RAX => 64-bit register that hold the return value of a function
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

MEMORY LAYOUT: https://raw.githubusercontent.com/0xZ0F/Z0FCourse_ReverseEngineering/master/Chapter%203%20-%20Assembly/%5Bignore%5D/WindowsMemoryLayoutRF.png

Memory segments:
- Stack - Holds non-static local variables. Discussed more in-depth soon.
- Heap - Contains dynamically allocated data that can be uninitialized at first.
- .data - Contains global and static data initialized to a non-zero value.
- .bss - Contains global and static data that is uninitialized or initialized to zero.
- .text - Contains the code of the program (don't blame me for the name, I didn't make it).


Things such as structures and user input might be stored on the heap.
Program Image - This is the program/executable loaded into memory. On Windows, this is typically a Portable Executable (PE).
TEB - The Thread Environment Block (TEB) stores information about the currently running thread(s).
PEB - The Process Environment Block (PEB) stores information about the process and the loaded modules.

Stack frame: https://raw.githubusercontent.com/0xZ0F/Z0FCourse_ReverseEngineering/master/Chapter%203%20-%20Assembly/%5Bignore%5D/StackFrameLayoutRF.png
```
mov RAX, 15 ;RAX = 15
call func   ;Call func. Same as func();
mov RBX, 23 ;RBX = 23. This line is saved as the return address for the function call.
```
On x64, it's common to see RBP used in a non-traditional way (compared to x86). 
Sometimes only RSP is used to point to data on the stack such as local variables and function parameters, and RBP is used for general data (similar to RAX). 
This will be discussed in further detail later.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------














