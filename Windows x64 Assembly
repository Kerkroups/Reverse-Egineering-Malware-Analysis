Base 10:

Base 10 includes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
Here is 243 in base 10:
243 = (102 * 2) + (101 * 4) + (100 * 3) = 200 + 40 + 3.

Base 7:
243(in base 7) = (72 * 2) + (71 * 4) + (70 * 3) = 98 + 28 + 3 = 129(in decimal).
Base 7 includes 0, 1, 2, 3, 4, 5, 6.
9 isn't in base 7, so how do we represent it in base 7?
9(in decimal) = (71 * 1) + (70 * 2) = 7 + 2. Our answer is going to be 12(base7) = 9(base10).

Base 2:
Base2/Binary:
What about base 2? Base 2 includes 0 and 1. It works the same as the others. Here are some good values to know:
210 = 1024, 29 = 512, 28 = 256, 27 = 128, etc.

Hexadecimal/Base 16:

BiTS AND BYTES(https://www.tutorialspoint.com/cprogramming/c_data_types.htm):
- Bit is one binary digit. Can be 0 or 1.
- Nibble is 4 bits.
- Byte is 8 bits.
- Word is 2 bytes.
- Double Word (DWORD) is 4 bytes. Twice the size of a word.
- Quad Word (QWORD) is 8 bytes. Four times the size of a word.

- Char - 1 byte (8 bits).
- Signed Int:
    16 bit is -32,768 to 32,767.
    32 bit is -2,147,483,648 to 2,147,483,647.
    64-bit is -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.

- Unsigned Int - Minimum is zero, maximum is twice that of a signed int (of the same size).
- Bool - 1 byte.

BINARY OPERATIONS:

- NOT ("!"): NOT 1 = 0, NOT 0 = 1, !1100 = 0011;
- AND ("&"): 1 AND 1 = 1, 1 AND 0 = 0, 0 AND 0 = 0, 1100 AND 1010 = 1000;
- OR ("|"): 1 OR 1 = 1, 1 OR 0 = 1, 0 OR 0 = 0, 1100 | 1010 = 1110;
- XOR ("^"): 1 XOR 1 = 0, 1 XOR 0 = 1, 0 XOR 0 = 0, 1100 ^ 1010 = 0110;
- NAND: NOT AND;
- NOR: NOT OR;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
REGISTERS(https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture):
RAX - Known as the accumulator register. Often used to store the return value of a function.
RBX - Sometimes known as the base register, not to be confused with the base pointer. Sometimes used as a base pointer for memory access.
RDX - Sometimes known as the data register.
RCX - Sometimes known as the counter register. Used as a loop counter.
RSI - Known as the source index. Used as the source pointer in string operations.
RDI - Known as the destination index. Used as the destination pointer in string operations.
RSP - The stack pointer. Holds the address of the top of the stack.
RBP - The base pointer. Holds the address of the base (bottom) of the stack.

If the data is too large to fit in a register, a register will hold a pointer to the data so it can be accessed.
##############################################################
PUSH instruction could be used to save a register in a way that it can later be restored.
В языках подобных С++ имплементированы два метода: Call и Ret, Call создает инструкцию с адресом(в бинарной нотации) и кладет на верхний уровень стека, Ret не содержит адреса, этот метод просто забирает верхнюю инструкцию и возвращает нас по указанному адресу. 
Сам стек, после возвращения данных и выполнения функций уничтожается и данные из него недоступны.
##############################################################
RAX is 64 bits, the lower 32 bits can be referenced with EAX, and the lower 16 bits can be referenced with AX. AX is broken down into two 8 bit portions. 
The high/upper 8 bits of AX can be referenced with AH. The lower 8 bits can be referenced with AL.

RAX consists of all 8 bytes which would be bytes 0-7. 
EAX consists of bytes 4-7, AX consists of bytes 6-7, AH consists of only byte 6, and AL consists of only byte 7 (the final byte).

RAX = 0x0123456789ABCDEF
EAX = 0x89ABCDEF
AX = 0xCDEF
AH = 0xCD
AL = 0xEF
##############################################################
FLOAT-POINT DATA TYPE REGISTERS:
YMM0 to YMM15 (64-bit) and XMM0 to XMM15 (32-bit).
The XMM registers are the lower half of the YMM registers, similar to how EAX is the lower 32 bits of RAX. 
Something unique about these registers is that they can be treated as arrays. In other words, they can hold multiple values. 
For example, YMM# registers are 256-bit wide each and can hold 4 64-bit values or 8 32-bit values. 
Similarly, the XMM# registers are 128-bits wide and can hold 2 64-bit values or 4 32-bit values.

EXTRA REGISTERS:
There are registers r8 to r15 which are designed to be used by integer type values (not floats or doubles).
R8 - Full 64-bit (8 bytes) register.
R8D - Lower double word (4 bytes).
R8W - Lower word (2 bytes)
R8B - Lower byte.
##############################################################
In C/C++ you can use dereferencing to get the value inside of a memory address.
Dereferencing:
```
int main(){
    int num = 10;
    int* ptr = &num; //ptr is a pointer to num, which means ptr is holding the memory address of num.
    return (*ptr + 5); //Then return the sum of what's at the address inside ptr (num which is 10) and 5.
}
```
##############################################################
LEA and square brackets:
- Square Brackets - Square brackets dereference in assembly. 
  For example, [var] is the address pointed to by var. In other words, when using [var] we want to access the memory address that var is holding.

- LEA - Ignore everything about square brackets when working with LEA. LEA is short for Load Effective Address and it's used for calculating and loading addresses.
        It's important to note that when working with the LEA instruction, square brackets do not dereference.
        LEA is used to load and calculate addresses, NOT data.
##############################################################
EXAMPLE 1:
lea RAX, [var] => load address of var in RAX; RAX is now acting as a pointer since it holds the address to the variable.
mov [RAX], 12 //Then 12 is moved into the address pointed to by RAX. The address pointed to by RAX is the var variable. If that Assembly was executed, var would be 12. 
                This is all the same as doing mov var, 12.
EXAXPLE 2:
lea RAX, [RCX+8] ;This will add 8 to the address inside RCX, and set RAX to the resulting address.
mov RAX, [RCX+8] ;This will add 8 to the address already held by RCX, then dereference the new address and put whatever is at that address into RAX.
##############################################################
MOVZX (MOVE ZERO EXTENSION):
Move to the lower 32 bits of RAX via EAX will zero out/zero extend the upper 32 bits. 
A move to anything less will not zero extend. So moving something into AX will not zero out the rest of RAX. 
If you do want to zero extend no matter what, use movzx which performs zero extension no matter what.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JUMP:
For unsigned comparisons:
- JB/JNAE (CF = 1) ; Jump if below/not above or equal
- JAE/JNB (CF = 0) ; Jump if above or equal/not below
- JBE/JNA (CF = 1 or ZF = 1) ; Jump if below or equal/not above
- JA/JNBE (CF = 0 and ZF = 0); Jump if above/not below or equal

For signed comparisons:
- JL/JNGE (SF <> OF) ; Jump if less/not greater or equal
- JGE/JNL (SF = OF) ; Jump if greater or equal/not less
- JLE/JNG (ZF = 1 or SF <> OF); Jump if less or equal/not greater
- JG/JNLE (ZF = 0 and SF = OF); Jump if greater/not less or equal
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

STATUS FLAGS:
- Zero Flag (ZF) - Set if the result of an operation is zero. Not set if the result of an operation is not zero.
- Carry Flag (CF) - Set if the last unsigned arithmetic operation carried (addition) or borrowed (subtraction) a bit beyond the register. It's also set when an operation would be negative if it wasn't for the operation being unsigned.
- Overflow Flag (OF) - Set if a signed arithmetic operation is too big for the register to contain.
- Sign Flag (SF) - Set if the result of an operation is negative.
- Adjust/Auxiliary Flag (AF) - Same as the carry flag but for Binary Coded Decimal (BCD) operations.
- Parity Flag (PF) - Set to 1 if the number of bits set in the last 8 bits is even. (10110100, PF=1; 10110101, PF=0)
- Trap Flag (TF) - Allows for single-stepping of programs.












